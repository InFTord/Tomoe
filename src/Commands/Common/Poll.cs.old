using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using DSharpPlus;
using DSharpPlus.CommandsNext;
using DSharpPlus.CommandsNext.Attributes;
using DSharpPlus.CommandsNext.Converters;
using DSharpPlus.Entities;
using Microsoft.Extensions.DependencyInjection;
using OoLunar.Tomoe.Database;
using OoLunar.Tomoe.Services;
using OoLunar.Tomoe.Utilities;

namespace OoLunar.Tomoe.Commands.Common
{
    public sealed class Poll : BaseCommandModule
    {
        public DiscordExpireTimer<PollModel> PollService { private get; init; } = null!;

        [Command("poll")]
        [RequireBotPermissions(Permissions.SendMessages | Permissions.EmbedLinks)]
        public Task PollAsync(CommandContext context, string pollTitle, TimeSpan timeSpan, [RemainingText] params string[] wordAndEmojiList) => PollAsync(context, pollTitle, DateTimeOffset.UtcNow.Add(timeSpan), wordAndEmojiList);

        [Command("poll")]
        [Description("Create a poll.")]
        [RequireBotPermissions(Permissions.SendMessages | Permissions.EmbedLinks)]
        public async Task PollAsync(CommandContext context, string pollTitle, DateTimeOffset? dateTimeOffset = null, [RemainingText] params string[] wordAndEmojiList)
        {
            // Pre-execution checks.
            if (string.IsNullOrWhiteSpace(pollTitle))
            {
                await context.RespondAsync("Please provide a valid title for the poll. An empty or whitespace title is not allowed.");
                return;
            }

            List<string> choices = new();
            foreach (string choice in wordAndEmojiList) // wordAndEmojiList.Select(choice => choice.Trim()).Where(choice => !string.IsNullOrWhiteSpace(choice)).Distinct()
            {
                // Trim and remove duplicates. Extraneous whitespace can occur from quoted parameters.
                string trimmedChoice = choice.Trim();
                if (string.IsNullOrWhiteSpace(trimmedChoice) || choices.Contains(trimmedChoice))
                {
                    continue;
                }
                choices.Add(trimmedChoice);
            }

            if (choices.Count is < 2 or > 24)
            {
                await context.RespondAsync("Please provide at least two choices and at most 24 choices.");
                return;
            }

            dateTimeOffset ??= DateTimeOffset.UtcNow.AddMinutes(5);
            if (dateTimeOffset < DateTimeOffset.UtcNow)
            {
                await context.RespondAsync("Please provide a valid date and time in the future.");
                return;
            }

            // Create the poll message.
            DiscordEmbedBuilder embedBuilder = new()
            {
                Title = $"Poll Time!",
                Description = pollTitle,
                Color = new DiscordColor(0x6b73db),
            };
            embedBuilder.AddField("Options", string.Join("\n", choices));
            embedBuilder.AddField("Expires at", $"{Formatter.Timestamp(dateTimeOffset.Value, TimestampFormat.ShortDateTime)} ({Formatter.Timestamp(dateTimeOffset.Value, TimestampFormat.RelativeTime)})", true);
            embedBuilder.AddField("Votes", $"0 votes so far. {Formatter.Italic("You")}  could be the change!", true); // Double space is intentional.

            PollModel pollModel = new(context.User.Id, context.Guild.Id, context.Channel.Id, dateTimeOffset.Value, pollTitle, choices.ToDictionary(choice => choice, choice => new List<ulong>()));
            PollService.Add(pollModel);

            IArgumentConverter<DiscordEmoji> emojiArgumentConverter = new DiscordEmojiConverter();
            List<DiscordActionRowComponent> buttonRows = new();
            List<DiscordComponent> buttons = new();
            for (int i = 0; i < choices.Count; i++)
            {
                string choice = choices[i];
                string[] choiceSplit = choice.Split(' ');
                Optional<DiscordEmoji> optionalEmoji = await emojiArgumentConverter.ConvertAsync(choiceSplit[0], context);
                if (optionalEmoji.HasValue)
                {
                    buttons.Add(new DiscordButtonComponent(ButtonStyle.Secondary, $"poll-{pollModel.Id}-{i}", string.Join(' ', choiceSplit.Skip(1)), false, new(optionalEmoji.Value)));
                }
                else
                {
                    buttons.Add(new DiscordButtonComponent(ButtonStyle.Secondary, $"poll-{pollModel.Id}-{i}", choice, false));
                }

                if (buttons.Count == 5)
                {
                    buttonRows.Add(new(buttons));
                    buttons.Clear();
                }
            }

            buttons.Add(new DiscordButtonComponent(ButtonStyle.Danger, $"poll-{pollModel.Id}-remove", "Remove my vote!"));
            buttonRows.Add(new DiscordActionRowComponent(buttons));

            DiscordMessageBuilder messageBuilder = new();
            messageBuilder.AddEmbed(embedBuilder.Build());
            messageBuilder.AddComponents(buttonRows);

            DiscordMessage message = await context.RespondAsync(messageBuilder);
            pollModel.MessageId = message.Id;
        }

        public static async Task UpdatePollCountAsync(IServiceProvider serviceProvider, PollModel pollModel, IEnumerable<ulong>? userIds)
        {
            DiscordShardedClient shardedClient = serviceProvider.GetRequiredService<DiscordShardedClient>();

            Optional<DiscordMessage?> pollMessage = await shardedClient.GetMessageAsync(pollModel.ChannelId, pollModel.MessageId, pollModel.GuildId);
            if (!pollMessage.HasValue)
            {
                // Message, channel or guild is now  g o n e
                return;
            }
            else if (pollMessage.Value == null)
            {
                // The guild is unavailable or Discord threw a 500 error.
                if (userIds != null)
                {
                    //DiscordBurstTimer<PollModel> actionQueue = serviceProvider.GetRequiredService<DiscordBurstTimer<PollModel>>();
                    //actionQueue.AddRange(pollModel, userIds);
                }
                return;
            }
            else if (pollModel.ExpiresAt <= DateTimeOffset.UtcNow)
            {
                // The poll has expired.
                return;
            }
            else if ($"{pollModel.TotalVoteCount:N0}" == pollMessage.Value.Embeds[0].Fields[2].Value.Split(' ')[0])
            {
                return;
            }

            DiscordEmbedBuilder embedBuilder = new(pollMessage.Value.Embeds[0]); // Indexing the embeds is safe here because supressing embeds is actually a flag, not a message modification.
            embedBuilder.Fields[2].Value = $"{pollModel.TotalVoteCount:N0} vote{(pollModel.TotalVoteCount == 1 ? '.' : "s!")}";
            await pollMessage.Value.ModifyAsync(embedBuilder.Build());
        }
    }
}
